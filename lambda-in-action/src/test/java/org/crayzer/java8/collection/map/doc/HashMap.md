### [厉害了！把 HashMap 剖析的只剩渣了！](https://mp.weixin.qq.com/s/3JuPUqsUJwSfBInilY9zRg)

#### 散列函数
- HashMap通过高16位与低16位进行异或运算来让高位参与散列，提高散列效果；
- HashMap控制数组的长度为2的整数次幂来简化取模运算(hashcode与数组长度-1进行位与运算)，提
  高性能；
- HashMap通过控制初始化的数组长度为2的整数次幂、扩容为原来的2倍来控制数组长度一定为2的
  整数次幂。
  - 初始化时指定的长度(**tableSizeFor(initialCapacity), 作用是使得最高位1后续的所有位都变为
    1，最后再+1则得到刚好大于initialCapacity的最小2的整数次幂数**)
  - 注意：tableSizeFor() 中 `int n = cap - 1;`  如果指定的数刚好是2的整数次幂，如果没有-1结果会变
    成比他大两倍的数，00100 --高位1之后全变1--> 00111 --加1---> 01000
  - 扩容时的长度增量
  
#### 哈希冲突
> 解决hash冲突的方式很多，如开放定址法、再哈希法、公共溢出表法、链地址法。

- HashMap采用链地址法，当发生冲突时会转化为链表，当链表过长会转化为红黑树提高效率。
- HashMap对红黑树进行了限制，让红黑树只有在极少数极端情况下进行抗压。

##### 关于红黑树的转化
- 当链表的长度>=8且数组长度>=64时，会把链表转化成红黑树。
- 当链表长度>=8，但数组长度<64时，**会优先进行扩容，而不是转化成红黑树**。(`treeifyBin()`)
- 当红黑树节点数<=6，自动转化成链表。

##### 为什么需要数组长度到64才会转化红黑树？
- 如数组长度为16，链表长度达到8已经是占用了最大限度的50%，意味着负载已经快要达到上限，此时如
  果转化成红黑树，之后的扩容又会再一次把红黑树拆分平均到新的数组中，这样非但没有带来性能的好
  处，反而会降低性能。
  
##### 为什么要大于等于8转化为红黑树，而不是7或9？
- 树节点的比普通节点更大，在链表较短时红黑树并未能明显体现性能优势；
- 在理论数学计算中（装载因子=0.75），链表的长度到达8的概率是百万分之一；
- 把7作为分水岭，大于7转化为红黑树，小于7转化为链表。

#### 扩容方案(利用空间换时间)
> 装载因子决定了HashMap扩容的阈值，需要权衡时间与空间，一般情况下保持0.75不作改动； HashMap
> 扩容机制结合了数组长度为2的整数次幂的特点，以一种更高的效率完成数据迁移，同时避免头插法造成
> 链表环。

- 装载因子=HashMap中节点数/数组长度
    - 装载因子越大，数组利用率越高，同时发生哈希冲突的概率也就越高； 
    - 装载因子越小，数组利用率降低，但发生哈希冲突的概率也降低了;
    - 在理论计算中，0.75是一个比较合适的数值，大于0.75哈希冲突的概率呈指数级别上升，而小于
      0.75冲突减少并不明显

##### JDK1.7之前的数据迁移
> 遍历所有的节点，把所有的节点依次通过hash函数计算新的下标，再插入到新数组的链表中

**缺点：**
1、每个节点都需要进行一次求余计算；
2、插入到新的数组时候采用的是头插入法，在多线程环境下会形成链表环

##### jdk1.8之后进行了优化
- 原因在于他控制数组的长度始终是2的整数次幂，每次扩展数组都是原来的2倍，带来的好处是key在新的
数组的hash结果只有两种：
    - 在原来的位置 
    - 或者在原来位置+原数组长度
- **在新数组中的hash结果，仅仅取决于高一位的数值。如果高一位是0，那么计算结果就是在原位置，而
  如果是1，则加上原数组的长度即可**。这样我们只需要判断一个节点的高一位是1 or 0就可以得到他在新
  数组的位置，而不需要重复hash计算。HashMap把每个链表拆分成两个链表，对应原位置或原位置+原
  数组长度，再分别插入到新的数组中，保留原来的节点顺序。
```
// HashMap#resize()
// line:721
// 如果高一位是0，那么计算结果就是在原位置，否则在原位置+老数组的长度
// 把原链表拆成两个链表，然后再分别插入到新数组的两个位置上
// 不用多次调用put方法

// 分别是原位置不变的链表和原位置+原数组长度位置的链表
Node<K,V> loHead = null, loTail = null;
Node<K,V> hiHead = null, hiTail = null;
Node<K,V> next;
// 遍历老链表
do {
    next = e.next;
    // 判断新增判定位是1or0进行分类
    if ((e.hash & oldCap) == 0) {
        if (loTail == null)
            loHead = e;
        else
            loTail.next = e;
        loTail = e;
    }
    else {
        if (hiTail == null)
            hiHead = e;
        else
            hiTail.next = e;
        hiTail = e;
    }
} while ((e = next) != null);
// 最后赋值给新的数组
if (loTail != null) {
    loTail.next = null;
    newTab[j] = loHead;
}
if (hiTail != null) {
    hiTail.next = null;
    newTab[j + oldCap] = hiHead;
}
```
  
#### 线程安全
> ConcurrentHashMap类或者Collections.synchronizeMap()方法或者Hashtable都只能在一定的限度上保
> 证线程安全，而无法保证绝对线程安全
> 
> 快速失败是HashMap迭代机制中的一种并发安全保证 `transient int modCount;`

#### 源码解读
- HashMap# `resize()` 扩容
- HashMap# `putVal()` 添加数值
    - 总体上分为两种情况：找到相同的key和找不到相同的key。找了需要判断是否更新并返回旧value，
      没找到需要插入新的Node、更新节点数并判断是否需要扩容。
    - 查找分为三种情况：数组、链表、红黑树。数组下标i位置不为空且不等于key，那么就需要判断是否
      树节点还是链表节点并进行查找。
    - 链表到达一定长度后需要扩展为红黑树，**当且仅当链表长度>=8且数组长度>=64**。
  
#### 其他问题
1. 为什么jdk1.7以前控制数组的长度为素数，而jdk1.8之后却采用的是2的整数次幂？
> 素数长度可以有效减少哈希冲突；JDK1.8之后采用2的整数次幂是为了提高求余和扩容的效率，同时结
> 合高低位异或的方法使得哈希散列更加均匀。

- hashcode在1~20均匀分布，那么无论长度是合数4，还是素数5，分布都是均匀的。而如果hashcode之间
  的间隔都是2，如1,3,5...,那么长度为4的数组，位置2和位置4两个下标无法放入数据，而长度为5的数组
  则没有这个问题。**长度为合数的数组会使间隔为其因子的hashcode聚集出现，从而使得散列效果降低。**
  
```
System.out.println(1 % 4); // 1
System.out.println(3 % 4); // 3
System.out.println(5 % 4); // 1
System.out.println(7 % 4); // 3

System.out.println("=====");
System.out.println(1 % 5); // 1
System.out.println(3 % 5); // 3
System.out.println(5 % 5); // 0
System.out.println(7 % 5); // 2
```

2. 为什么插入HashMap的数据需要实现hashcode和equals方法？对这两个方法有什么要求？
> 通过hashcode来确定插入下标，通过equals比较来寻找数据；两个相等的key的hashcode必须相等，但
> 拥有相同的hashcode的对象不一定相等。
> 
> HashMap比较两个元素是否相同采用了三种比较方法结合：
> `p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))) `
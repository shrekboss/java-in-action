### 迭代器模式的原理和实现
一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容
器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。

**迭代器模式主要作用是解耦容器代码和遍历代码**

### Iterator 接口的定义
```java

// 接口定义方式一
public interface Iterator<E> {
  boolean hasNext();
  void next();
  E currentItem();
}

// 接口定义方式二
// 返回当前元素与后移一位这两个操作，要放到同一个函数 next() 中完成
public interface Iterator<E> {
  boolean hasNext();
  E next();
}
```

### 迭代器模式的优势
遍历集合数据有三种方法：for 循环、foreach 循环、iterator 迭代器(foreach 循环只是一个语法糖而已，底
层是基于迭代器来实现的)
- 迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；
- 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；
- 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，
在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。

### 在遍历的同时增删集合元素会发生什么？
在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历
不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期
行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定。

两种比较干脆利索的解决方案：
- 一种是遍历的时候不允许增删元(比较难实现，无法有效的确定遍历结束时间)
- **另一种是增删元素之后让遍历报错(Java 语言就是采用的这种解决方案)**

### 在 Java 中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什么呢？如何来
解决这个问题呢？
Iterator#remove()中, 调用外部类ArrayList#remove(), 通过下标移除元素. ArrayList内部维护modCount成员
变量, 表示一次遍历中修改次数. Iterator通过remove()修改前, **会核对Iterator自己的exceptedModCount 和 
ArrayList的modCount是否一致, 若不一致, 说明出现了并发问题, 会抛出 ConcurrentModificationException 异
常.** 若一致, 正常移除数据, 并更新modCount。

结论: 
**1. 通过Iterator遍历集合时, 必须通过 Iterator#remove() 移除元素。**
**2. 避免在并发情形修改集合, 或使用 CopyOnWriteArrayList。**
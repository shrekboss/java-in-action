> 装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。
> 这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始
> 类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。
>
### 装饰器模式特殊的地方
- **装饰器类和原始类继承同样的父类**，可以对原始类“嵌套”多个装饰器类。
- 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。

### 代理模式 VS 装饰器模式
**代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增
强功能。**

### 参考 Java IO 的这种设计思路
BufferedInputStream 类的代码，InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、
available()）都有默认实现，按理来说，只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能
的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。对于即便是不需要
增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对
象的函数调用。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进
来的 InputStream 对象来完成。
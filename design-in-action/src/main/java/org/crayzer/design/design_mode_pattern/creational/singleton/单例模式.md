> 单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），
> 那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

### 为什么要使用单例？
有些数据在系统中只应该保存一份，就比较适合设计为单例类
- 饿汉式
    - 饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的
    创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。
- 懒汉式
    - 懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等
    问题，频繁的调用会产生性能瓶颈。
- 双重检测
    - 双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用
     getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。
 - 静态内部类
    - 利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比
    双重检测简单。
  - 枚举
    - 最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了
    实例创建的线程安全性和实例的唯一性。

### 单例存在哪些问题？
- 单例对 OOP 特性的支持不友好
    - 用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性
    - 选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当
    于损失了可以应对未来需求变化的扩展性
- 单例会隐藏类之间的依赖关系
- 单例对代码的扩展性不友好
- 单例对代码的可测试性不友好
- 单例不支持有参数的构造函数

### 单例与静态类的区别？


### 有何替代的解决方案？
为了保证全局唯一，除了使用单例，还可以用静态方法来实现

### 如何理解单例模式中的唯一性？
单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯
一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进
程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。

- **对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader）**
    - classloader有两个作用：
        1. 用于将class文件加载到JVM中；
        2. 确认每个类应该由哪个类加载器加载，并且也用于判断JVM运行时的两个类是否相等。
    - 双亲委派模型
        - 当一个类加载器接收到类加载请求时，首先会请求其父类加载器加载，每一层都是如此，当父类加载
        器无法找到这个类时（根据类的全限定名称），子类加载器才会尝试自己去加载。所以双亲委派模型解
        决了类重复加载的问题。
        
### 如何实现线程唯一的单例？
通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。不同的线程对应不同的对象，同一个线
程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单
例。不过，ThreadLocal 底层实现原理也是基于 HashMap。

### 如何实现集群环境下的单例？
需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先
从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共
享存储区。

### 如何实现一个多例模式？
“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限
制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关
系，来控制对象的个数。























### 对重构概括性的介绍
- 重构的目的：为什么要重构（why）？
- 重构的对象：到底重构什么（what）？
- 重构的时机：什么时候重构（when）？
- 重构的方法：又该如何重构（how）？

### 保证重构不出错常用落地的技术手段
- 单元测试
    - 写单元测试的过程本身就是代码 Code Review 和重构的过程，能有效地发现代码中的 bug 和代码设计
    上的问题。
- 单元测试正确认识
    - 编写单元测试尽管繁琐，但并不是太耗时；
    - 可以稍微放低对单元测试代码质量的要求；
    - 覆盖率作为衡量单元测试质量的唯一标准是不合理的；
    - 单元测试不要依赖被测代码的具体实现逻辑；
    - 单元测试框架无法测试，多半是因为代码的可测试性不好。
    
 ### 其他常见的 Anti-Patterns
 - 未决行为
    - 所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码。
- 代码中包含未决行为逻辑；
- 滥用可变全局变量；
- 滥用静态方法；
- 使用复杂的继承关系；
- 高度耦合的代码。


### 如何发现代码质量问题-常规checklist
- 目录设置是否合理、模块划分是否清晰、代码结构是否满足「高内聚，低耦合」；
- 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD等）；
- 设计模式是否应用得当？是否有过度设计？
- 代码是否容易扩展？如果添加新功能，是否容易实现？
- 代码是否可以复用？是否可以服用已有的项目代码或类库？是否有重复造轮子？
- 代码是否容易测试？单元测试是否劝募覆盖各种正常和异常的情况？
-代码是否易读？是否符合代码规范？（比如命名和注释是否恰当、代码风格是否一致）？

### 如何发现代码质量问题-业务需求checklist
- 代码是否实现了预期的业务需求？
- 逻辑是否正确？是否处理了各种异常情况？
- 日志打印是否得当？是否方便debug排查问题？
- 接口是否易用？是否支持幂等、事务等？
- 代码是否存在并发问题？是否线程安全？
- 性能是否有优化空间，比如 SQL、算法是否可以优化？
- 是否有安全漏洞？比如，输入输出校验是否全面？

### 函数出错应该返回啥？
#### 错误码
- Java、Python 等比较新的编程语言中，大部分情况下，都用异常来处理函数出错的情况，极少会用到错
误码。
- 熟悉的编程语言中有异常这种语法机制，那就尽量不要使用错误码。
#### NULL 值
- **认为是一种不好的设计思路的原因**
    - 如果某个函数有可能返回 NULL 值，在使用它的时候，忘记了做 NULL 值判断，就有可能会抛出空
    指针异常（Null Pointer Exception，缩写为 NPE）。
    - 如果定义了很多返回值可能为 NULL 的函数，那代码中就会充斥着大量的 NULL 值判断逻辑，一方面写
    起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。
- 对于以 get、find、select、search、query 等单词开头的查找函数来说，数据不存在，并非一种异常情况，
**这是一种正常行为**。所以，返回代表不存在语义的 NULL 值比返回异常更加合理。
- **重要的参考标准**
    - 返回 NULL 值还是异常对象，要看获取不到数据是正常行为，还是异常行为。正常行为返回 NULL，否则
    返回异常。
    - 对于查找函数来说，除了返回数据对象之外，有的还会返回下标位置，比如 Java 中的 indexOf() 函数，
    用来实现在某个字符串中查找另一个子串第一次出现的位置。函数的返回值类型为基本类型 int。
        - 一种是：返回 NotFoundException
        - 一种是：返回一个特殊值，比如 -1。不过，显然 -1 更加合理，理由也是同样的，也就是说“没有查找
        到”是一种正常而非异常的行为。
#### 空对象(空字符串和空集合)
**当函数返回的数据是字符串类型或者集合类型的时候，可以用空字符串或空集合替代 NULL 值，来表示不存
在的情况。这样，在使用函数的时候，就可以不用做 NULL 值判断.**
#### 异常对象
> 对于运行时异常，在编写代码的时候，可以不用主动去 try-catch，编译器在编译代码的时候，并不会检查
> 代码是否有对运行时异常做了处理。相反，对于编译时异常，在编写代码的时候，需要主动去 try-catch 
> 或者在函数定义中声明，否则编译就会报错。所以，运行时异常也叫作非受检异常
>（Unchecked Exception），编译时异常也叫作受检异常（Checked Exception）。
- **最常用的函数出错处理方式**
- 异常可以携带更多的错误信息，比如函数调用栈信息。除此之外，异常可以将正常逻辑和异常逻辑的处理分
离开来，这样代码的可读性就会更好。

### 如何处理函数抛出的异常？
- **直接吞掉**
    - 如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，我们完全可以在 func2() 
    内将 func1() 抛出的异常吞掉；
- **原封不动地 re-throw**
    - 如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一
    定的相关性，我们可以选择直接将 func1 抛出的异常 re-throw；
- **包装成新的异常 re-throw**
    - 如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，
    可以将它重新包装成调用方可以理解的新异常，然后 re-throw。